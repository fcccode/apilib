#ifndef memreplace_h__
#define memreplace_h__

///////////////////////////////////////////////////////////////////////////////////////////////////

namespace apilib
{
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
  
  /**
   * Запись новых значений поверх старых типа 'char'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_char(void* data, size_t size, char old_value, char new_value);

  /**
   * Запись новых значений поверх старых типа 'unsigned char'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_uchar(void* data, size_t size, unsigned char old_value, unsigned char new_value);

  /**
   * Запись новых значений поверх старых типа 'short'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_short(void* data, size_t size, short old_value, short new_value);

  /**
   * Запись новых значений поверх старых типа 'unsigned short'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_ushort(void* data, size_t size, unsigned short old_value, unsigned short new_value);

  /**
   * Запись новых значений поверх старых типа 'long'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_long(void* data, size_t size, long old_value, long new_value);

  /**
   * Запись новых значений поверх старых типа 'unsigned long'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_ulong(void* data, size_t size, unsigned long old_value, unsigned long new_value);

  /**
   * Запись новых значений поверх старых типа 'long long'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_longlong(void* data, size_t size, long long old_value, long long new_value);

  /**
   * Запись новых значений поверх старых типа 'unsigned long long'.
   *
   * Поиск выполняется с шагом в 1 байт.
   * Перезаписанное значение пропускается полностью, чтобы не создавать коллизий.
   *
   * @param data      данные.
   * @param size      размер данных.
   * @param old_value значение для поиска.
   * @param new_value значение для записи поверх найденного.
   *
   * @return количество перезаписанных значений,
   *         0 если не найдено значений для перезаписи или произошла ошибка.
  */
  size_t memreplace_ulonglong(void* data, size_t size, unsigned long long old_value, unsigned long long new_value);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
};

///////////////////////////////////////////////////////////////////////////////////////////////////

#endif // memreplace_h__