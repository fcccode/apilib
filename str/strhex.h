#ifndef strhex_h__
#define strhex_h__

///////////////////////////////////////////////////////////////////////////////////////////////////

namespace apilib
{
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

  /**
   * Конвертация текстовой HEX последовательности в бинарные данные.
   *
   * Процедура содержит механизм расчета размера конечных данных на основании содержимого.
   * Позволяет определить требуемый размер буфера через вызов процедуры с указанием адреса 
   * буфера в качестве NULL (классическое применение в два последовательных вызова).
   *
   * @param string       текстовая HEX последовательности.
   * @param buffer       буфер для записи бинарных данных, допускается NULL.
   * @param buffer_size  размер буфера в байтах для записи бинарных данных.
   *
   * @return  требуемый размер буфера в байтах для записи бинарных данных,
   *          результат успешен если возвращаемое значение не превышает размер буфера,
   *          0 в случае ошибки.
  **/
  size_t strtohex_la(const char* string, void* buffer, size_t buffer_size);
  size_t strtohex_lw(const wchar_t* string, void* buffer, size_t buffer_size);

  /**
   * [Шаблон] Конвертация текстовой HEX последовательности в бинарные данные.
   *
   * Процедура содержит механизм расчета размера конечных данных на основании содержимого.
   * Позволяет определить требуемый размер буфера через вызов процедуры с указанием адреса 
   * буфера в качестве NULL (классическое применение в два последовательных вызова).
   *
   * @param string       текстовая HEX последовательности.
   * @param maxlen       максимальный длина текстовой HEX последовательности.
   * @param buffer       буфер для записи бинарных данных, допускается NULL.
   * @param buffer_size  размер буфера в байтах для записи бинарных данных.
   *
   * @return  требуемый размер буфера в байтах для записи бинарных данных,
   *          результат успешен если возвращаемое значение не превышает размер буфера,
   *          0 в случае ошибки.
  **/
  size_t strtohex_lna(const char* string, size_t maxlen, void* buffer, size_t buffer_size);
  size_t strtohex_lnw(const wchar_t* string, size_t maxlen, void* buffer, size_t buffer_size);

  /**
   * Генерация текстовой HEX-последовательности представляющей бинарные данные.
   *
   * Процедура содержит механизм быстрого предварительного расчета размера конечных данных.
   * Позволяет определить требуемый размер буфера через вызов процедуры с указанием адреса 
   * буфера в качестве NULL (классическое применение в два последовательных вызова).
   *
   * Данная процедура предназначена для записи коротких HEX последовательностей с заранее
   * предсказанным размером буфера, рекомендуется использовать безопасные версии процедуры
   * @link hextostrseq_lna или @link hextostrseq_lnw.
   *
   * @param binary     бинарные данные.
   * @param length     размер бинарных данных в байтах.
   * @param buffer     буфер для записи текстовых данных, допускается NULL.
   * @param separator  следует ли разделять символы пробелами, 1 - разделять, 0 - не разделять.
   * @param multiline  следует ли разделять символы на строки, 1 - разделять, 0 - не разделять.
   *
   * @return  требуемый размер буфера для записи результата без учета нулевого символа,
   *          результат успешно записан если возвращаемое значение меньше @link maxlen,
   *          0 в случае ошибки.
  */
  size_t strgenhexseq_la(const void* binary, size_t length, char* buffer, int separator, int multiline);
  size_t strgenhexseq_lw(const void* binary, size_t length, wchar_t* buffer, int separator, int multiline);

  /**
   * Генерация текстовой HEX-последовательности представляющей бинарные данные.
   *
   * Процедура содержит механизм быстрого предварительного расчета размера конечных данных.
   * Позволяет определить требуемый размер буфера через вызов процедуры с указанием адреса 
   * буфера в качестве NULL (классическое применение в два последовательных вызова).
   *
   * Конечные данные записываются только при условии достаточного размера буфера, 
   * частичная запись данных не осуществляется.
   *
   * @param binary     бинарные данные.
   * @param length     размер бинарных данных в байтах.
   * @param buffer     буфер для записи текстовых данных, допускается NULL.
   * @param maxlen     максимальная длина текстовых данных с учетом нулевого символа.
   * @param separator  следует ли разделять символы пробелами, 1 - разделять, 0 - не разделять.
   * @param multiline  следует ли разделять символы на строки, 1 - разделять, 0 - не разделять.
   *
   * @return  требуемый размер буфера для записи результата без учета нулевого символа,
   *          результат успешно записан если возвращаемое значение меньше @link maxlen,
   *          0 в случае ошибки.
  */
  size_t strgenhexseq_lna(const void* binary, size_t length, char* buffer, size_t maxlen, int separator, int multiline);
  size_t strgenhexseq_lnw(const void* binary, size_t length, wchar_t* buffer, size_t maxlen, int separator, int multiline);

  /**
   * Генерация текстовой HEX-таблицы представляющей бинарные данные.
   *
   * Процедура содержит механизм быстрого предварительного расчета размера конечных данных.
   * Позволяет определить требуемый размер буфера через вызов процедуры с указанием адреса 
   * буфера в качестве NULL (классическое применение в два последовательных вызова).
   *
   * Конечные данные записываются только при условии достаточного размера буфера, 
   * частичная запись данных не осуществляется.
   *
   * @param binary  бинарные данные.
   * @param length  размер бинарных данных в байтах.
   * @param buffer  буфер для записи текстовых данных, допускается NULL.
   * @param maxlen  максимальная длина текстовых данных с учетом нулевого символа.
   *
   * @return  требуемый размер буфера для записи результата без учета нулевого символа,
   *          результат успешно записан если возвращаемое значение меньше @link maxlen,
   *          0 в случае ошибки.
  **/
  size_t strgenhextbl_lna(const void* binary, size_t length, char* buffer, size_t maxlen);
  size_t strgenhextbl_lnw(const void* binary, size_t length, wchar_t* buffer, size_t maxlen);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
};

///////////////////////////////////////////////////////////////////////////////////////////////////

#endif // strhex_h__